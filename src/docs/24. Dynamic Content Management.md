# Cloud Explorer: Dynamic Content Management & User Initialization Plan

## 1. Introduction

This document outlines the strategy and implementation steps for evolving the Cloud Explorer application's content management. Currently, a static script (`scripts/create-schema.ts`) pre-populates Firestore with modules (reading from local `.md` files), quizzes, exams, and sample user data.

**Goal:** Replace the static script with a dynamic system where:

1. Core learning content (Modules, Quizzes, Exams) is managed via a backend API.
2. Module content is stored as Markdown directly in Firestore.
3. Quiz and Exam questions are generated by AI (via admin action) and stored in Firestore.
4. New users are automatically initialized with necessary profile data and empty progress structures upon signup using Firebase Auth triggers.

This approach enhances scalability, maintainability, and allows for dynamic content updates without script executions or code deployments.

## 2. Core Strategy: Shared Content + User-Specific Progress

We will adopt a standard model for learning platforms:

* **Shared Content:** Global Firestore collections (`modules`, `quizzes`, `exams`) will store the definitions and content accessible to all users. Module content will be stored as Markdown text within section documents. Quiz/Exam questions, once generated, will be stored within their respective documents.
* **User Initialization:** A Firebase Cloud Function triggered by user creation (`functions.auth.user().onCreate`) will create a document for the new user in the `users` collection, initializing their profile, default settings, and *empty* `learningProgress`.
* **User-Specific Progress:** Existing backend API endpoints (`trackProgress`, `saveQuizResult`, `saveExamResult`, etc.) will record user interactions by creating documents in collections like `quizResults`, `examResults`, and the user's `progress` subcollection, linking the `userId` to the shared content IDs (`moduleId`, `quizId`, `examId`).

**Benefits:**

* **Data Efficiency:** Avoids massive duplication of content for each user.
* **Maintainability:** Shared content can be updated centrally via admin tools.
* **Scalability:** Easily handles a growing number of users and content items.

## 3. Backend Implementation (`backend/`)

The Node.js/Express backend requires updates to manage content and provide admin capabilities.

### 3.1. Authentication & Authorization Middleware (Admin Protection)

All Admin Endpoints listed below **must** be protected. Create middleware (e.g., `backend/middleware/authMiddleware.js`) to:

1. **Verify Firebase ID Token:** Use `admin.auth().verifyIdToken(token)` to authenticate the request.
2. **Check Admin Role:** Verify if the authenticated user has admin privileges. This can be done by checking:
    * A custom claim set on the user's token (e.g., `decodedToken.admin === true`). Custom claims are set using the Admin SDK.
    * A specific field in the user's Firestore document (e.g., `/users/{userId}.role === 'admin'`).
3. Reject requests from non-authenticated or non-admin users with a 401 or 403 status.

**Conceptual Example (`backend/middleware/authMiddleware.js`):**

```javascript
const admin = require('firebase-admin');
const AppError = require('../utils/appError'); // Assuming AppError setup

// Middleware to verify Firebase token and user existence
const protect = async (req, res, next) => {
  let token;
  if (req.headers.authorization && req.headers.authorization.startsWith('Bearer')) {
    token = req.headers.authorization.split(' ')[1];
  }

  if (!token) {
    return next(new AppError('No token provided. Authentication required.', 401, 'AUTH_NO_TOKEN'));
  }

  try {
    const decodedToken = await admin.auth().verifyIdToken(token);
    req.user = decodedToken; // Attach user info to the request object

    // Optional: Check if user exists in Firestore DB (might be redundant if Auth is source of truth)
    // const userDoc = await admin.firestore().collection('users').doc(req.user.uid).get();
    // if (!userDoc.exists) {
    //    return next(new AppError('User associated with token not found.', 401, 'AUTH_USER_NOT_FOUND'));
    // }

    next();
  } catch (error) {
    console.error('Token verification failed:', error.message);
    return next(new AppError('Invalid or expired token. Please log in again.', 401, 'AUTH_INVALID_TOKEN'));
  }
};

// Middleware to check for Admin role (example using custom claims)
const adminOnly = (req, res, next) => {
  if (req.user && req.user.admin === true) { // Check for custom claim 'admin'
    next();
  } else {
    // Check Firestore role if not using custom claims (requires another DB read)
    // Example: checkUserRole(req.user.uid, 'admin').then(isAdmin => ...)
    return next(new AppError('Access denied. Admin privileges required.', 403, 'AUTH_ADMIN_REQUIRED'));
  }
};

module.exports = { protect, adminOnly };
```

**Note**: Implement the role-checking mechanism (custom claims or Firestore field) based on your preference.

### 3.2. Admin Endpoints

Add the following routes and controller logic. Remember to apply the **protect** and **adminOnly** middleware in the router files.

#### A. Module Endpoints

(In **backend/controllers/moduleController.js** & **backend/routes/moduleRoutes.js**)

* **POST /api/v1/modules** (**Admin**)
  * **Body**: { **title: string, description: string, duration?: number, prerequisites?: string[], sections: [{ title: string, content: string (Markdown), order: number** }] }
  * Logic: Creates module doc & section subcollection docs with Markdown content.
  * Example Controller Snippet (**moduleController.js**):

```javascript
exports.createModuleWithSections = async (req, res, next) => {
    try {
        const { title, description, duration, prerequisites, sections } = req.body;

        // --- Validation ---
        if (!title || typeof title !== 'string' || title.trim() === '') {
            return next(new AppError('Module title is required.', 400, 'VALIDATION_ERROR'));
        }
        if (!description || typeof description !== 'string') {
             return next(new AppError('Module description is required.', 400, 'VALIDATION_ERROR'));
        }
         if (!Array.isArray(sections) || sections.length === 0) {
             return next(new AppError('Module must have at least one section.', 400, 'VALIDATION_ERROR'));
         }
         // Add more validation for section content, order, etc.

        const moduleId = title.toLowerCase().replace(/\s+/g, '-').replace(/[^a-z0-9-]/g, ''); // Basic ID generation
        const moduleRef = db.collection('modules').doc(moduleId);

        const moduleData = {
            moduleId, // Store ID in document too
            title,
            description,
            duration: duration || null,
            prerequisites: prerequisites || [],
            contentType: 'markdown', // Indicate content type
            createdAt: serverTimestamp(),
            updatedAt: serverTimestamp(),
            // quizIds: [], // Initialize empty quiz array?
        };

        // Use a batch for atomicity
        const batch = db.batch();
        batch.set(moduleRef, moduleData);

        sections.forEach((section, index) => {
            if (!section.title || !section.content || section.order === undefined) {
                throw new AppError(`Section ${index} is missing title, content, or order.`, 400, 'VALIDATION_ERROR');
            }
            const sectionRef = moduleRef.collection('sections').doc(`section-${section.order}`); // Or auto-ID
            batch.set(sectionRef, {
                title: section.title,
                content: section.content, // Store Markdown directly
                order: section.order,
                moduleId: moduleId, // Link back to module
            });
        });

        await batch.commit();
        console.log(`Admin: Created module ${moduleId} with ${sections.length} sections.`);

        res.status(201).json({ ...moduleData, moduleId: moduleRef.id, sections }); // Return created data

    } catch (error) {
        if (!error.isOperational && error.message?.includes('firestore')) {
            next(new AppError(`Database error creating module: ${error.message}`, 500, 'DB_SAVE_ERROR'));
        } else {
           next(error);
        }
    }
};

```

* **PUT /api/v1/modules/:moduleId** (**Admin**)
  * **Body**: Partial module data, including optional **sections** array.
  * **Logic**: Updates module doc. Handles section updates (overwrite or merge logic required).
* **DELETE /api/v1/modules/:moduleId** (**Admin**)
  * **Logic**: Deletes module doc. Requires separate logic (e.g., Cloud Function trigger or client-side iteration) to reliably delete the **sections** subcollection.

#### B. Quiz Endpoints

(In **backend/controllers/quizController.js** & **backend/routes/quizRoutes.js**)

* **POST /api/v1/quizzes/generate-and-save** (**Admin, Rate Limited**)
* **Body**: **:{ moduleId: string, title?: string, passingScore?: number, numberOfQuestions?: number, questionTypes?: string[] }**:
* **:Logic**: Fetches module content from Firestore, calls AI to generate questions, parses response, saves questions to a new document in **quizzes** collection, links to**moduleId**.
Example Controller Snippet (quizController.js):

```javascript
  exports.generateAndSaveQuiz = async (req, res, next) => {
    try {
        const { moduleId, title, passingScore = 70, numberOfQuestions = 5, questionTypes = ['multiple choice', 'true or false'] } = req.body;

        // --- Validation ---
        if (!moduleId) return next(new AppError('moduleId is required.', 400, 'VALIDATION_ERROR'));
         // Add other validations...

        // --- Fetch Module Content Context (from Firestore) ---
         const moduleRef = db.collection('modules').doc(moduleId);
         const moduleDoc = await moduleRef.get();
         if (!moduleDoc.exists) return next(new AppError(`Module ${moduleId} not found.`, 404, 'MODULE_NOT_FOUND'));
         const moduleData = moduleDoc.data();
         const sectionsSnapshot = await moduleRef.collection('sections').orderBy('order').get();
         let moduleContentContext = moduleData.description || '';
         sectionsSnapshot.forEach(doc => { moduleContentContext += ` ${doc.data().content || ''}`; });
         moduleContentContext = moduleContentContext.trim();
         if (!moduleContentContext) return next(new AppError(`No content found for module ${moduleId}.`, 404, 'MODULE_CONTENT_NOT_FOUND'));
         const quizTitle = title || `${moduleData.title || 'Module'} Quiz`;

        // --- Prepare AI Prompt ---
        const prompt = `Generate exactly ${numberOfQuestions} quiz questions based on: """${moduleContentContext}"""... [rest of prompt]`;

        // --- Call AI with Retry ---
         let generatedText = '';
         try {
             const result = await executeWithRetry(() => hf.textGeneration({ /* ... model, inputs: prompt, params ... */ }), 3, 15000);
             generatedText = result.generated_text;
         } catch (apiError) {
             throw new AppError(`AI model failed to generate quiz: ${apiError.message}`, 503, 'AI_SERVICE_ERROR');
         }

        // --- Parse Response ---
        const questions = parseQuizFromAIResponse(generatedText);
         if (questions.length === 0) {
            throw new AppError('Failed to parse valid quiz questions from AI.', 500, 'AI_RESPONSE_PARSE_FAILED');
         }

        // --- Save to Firestore ---
        const quizRef = db.collection('quizzes').doc(); // Auto-generate ID
        const quizData = {
            quizId: quizRef.id,
            moduleId: moduleId,
            title: quizTitle,
            passingScore: passingScore,
            questions: questions, // Store the generated questions array
            createdAt: serverTimestamp(),
            updatedAt: serverTimestamp(),
        };
        await quizRef.set(quizData);

        // Optional: Update module doc to link quizId
        // await moduleRef.update({ quizIds: admin.firestore.FieldValue.arrayUnion(quizRef.id) });

        console.log(`Admin: Generated and saved quiz ${quizRef.id} for module ${moduleId}.`);
        res.status(201).json(quizData);

    } catch (error) {
         next(error);
    }
};
```

* **PUT /api/v1/quizzes/:quizId** (**Admin**)
  * **Body**: **{ title?, passingScore?, questions?: [...] }** a.
  * **Logic**: Updates stored quiz document. Allows manual correction of AI-generated questions.
* **DELETE /api/v1/quizzes/:quizId** (**Admin**)
  * **Logic**:  Deletes quiz document.

#### Exam Endpoints

(In **backend/controllers/examController.js & backend/routes/examRoutes.js**)

* **POST /api/v1/exams/create** (**Admin**)- Use Existing / Refine
* **Body**: **{ examId: string, title: string, description: string, duration?: number, prerequisites?: string[], associatedModules?: string[] }**:
* **:Logic**:  Saves exam metadata. Ensure **associatedModules** is saved if needed by getExamContent.

* **POST /api/v1/exams/generate-and-save** (**Admin, Rate Limited**)
  * **Body**: **{ examId: string, numberOfQuestions?: number, questionTypes?: string[] }**
  * **Logic**: Fetches exam context using **getExamContent(examId)**, calls AI, parses response, updates the **exams/{examId**} document to add/replace the **questions** array (or saves to subcollection).
Example Controller Snippet (**examController.js**):

```javascript
exports.generateAndSaveExamQuestions = async (req, res, next) => {
    try {
         const { examId, numberOfQuestions = 25, questionTypes = ['multiple choice', 'true or false'] } = req.body;

         // --- Validation ---
         if (!examId) return next(new AppError('examId is required.', 400, 'VALIDATION_ERROR'));
          // Add other validations...

         // --- Fetch Exam Context ---
         const examRef = db.collection('exams').doc(examId);
         const examDoc = await examRef.get();
         if (!examDoc.exists) return next(new AppError(`Exam ${examId} not found.`, 404, 'EXAM_DEF_NOT_FOUND'));
         const examTitle = examDoc.data().title || 'Exam';
         const examContentContext = await getExamContent(examId); // Uses helper
         if (!examContentContext || examContentContext.length < 50) {
              console.warn(`Insufficient context for exam ${examId}. Generation might be less accurate.`);
         }

         // --- Prepare AI Prompt ---
         const prompt = `Generate exactly ${numberOfQuestions} challenging exam questions for "${examTitle}" based on: """${examContentContext}"""... [rest of prompt]`;

         // --- Call AI with Retry ---
         let generatedText = '';
         try {
             const result = await executeWithRetry(() => hf.textGeneration({ /* ... model, inputs: prompt, params ... */ }), 3, 30000);
             generatedText = result.generated_text;
         } catch (apiError) {
             throw new AppError(`AI model failed to generate exam questions: ${apiError.message}`, 503, 'AI_SERVICE_ERROR');
         }

         // --- Parse Response ---
         const questions = parseQuizFromAIResponse(generatedText);
         if (questions.length === 0) {
             throw new AppError('Failed to parse valid exam questions from AI.', 500, 'AI_RESPONSE_PARSE_FAILED');
         }

         // --- Save Questions to Firestore ---
         // Option 1: Update the main exam document
         await examRef.update({
             questions: questions, // Add/overwrite questions array
             questionsGeneratedAt: serverTimestamp(), // Track generation time
             updatedAt: serverTimestamp()
         });
         // Option 2: Save to subcollection (e.g., exams/{examId}/generatedQuestions/{docId})
         // const questionsRef = examRef.collection('generatedQuestions').doc(); // Or use a specific ID
         // await questionsRef.set({ questions, generatedAt: serverTimestamp() });

         console.log(`Admin: Generated and saved questions for exam ${examId}.`);
         res.status(200).json({ examId, title: examTitle, questions }); // Return generated questions

    } catch (error) {
        next(error);
    }
};
```

* **PUT /api/v1/exams/:examId** **(Admin)**
  * **Body**: Partial exam metadata and/or **questions** array.
  * **Logic**: Updates exam doc/subcollection.
* **DELETE /api/v1/exams/:examId** **(Admin)**
  * **Logic**: Deletes exam doc (and potentially questions subcollection).

### 3.3. Updated Routers

Ensure the new admin routes are added to **moduleRoutes.js**, **quizRoutes.js**, **examRoutes.js** and protected using the **protect** and **adminOnly** middleware.

**Example** (**quizRoutes.js**):

```javascript
const express = require('express');
const quizController = require('../controllers/quizController');
const { hfApiLimiter } = require('../server'); // Import limiter
const { protect, adminOnly } = require('../middleware/authMiddleware'); // Import auth middleware

const router = express.Router();

// --- Admin Routes ---
router.post('/generate-and-save', protect, adminOnly, hfApiLimiter, quizController.generateAndSaveQuiz);
router.put('/:quizId', protect, adminOnly, quizController.updateStoredQuiz); // Assuming updateStoredQuiz exists
router.delete('/:quizId', protect, adminOnly, quizController.deleteStoredQuiz); // Assuming deleteStoredQuiz exists

// --- User Routes ---
router.post('/save-result', protect, quizController.saveQuizResult);
router.get('/history/:userId', protect, quizController.getQuizHistory); // Or move to userRoutes
// Maybe a route to GET a specific stored quiz for taking?
// router.get('/:quizId/take', protect, quizController.getQuizForTaking);

module.exports = router;
```

(Apply similar patterns to other router files)

### 3.4. Utility Functions

* Ensure the utility functions are correctly placed and imported:

* **backend/utils/appError.js**: Centralized error class.
* **backend/utils/retryHandler.js**: **executeWithRetry** function.
* **backend/utils/aiHelpers.js**: **parseQuizFromAIResponse**, **getExamContent** functions.
* **backend/utils/firestoreHelpers.js**: **serverTimestamp**.
* **backend/utils/googleAuth.js**: **authenticateGoogleDocs**.

### 3.5. Server Configuration (server.js)

* **Make sure server.js**:

* Initializes **admin** SDK.
* Initializes **HfInference** and exports **hf**.
* Defines and exports **hfApiLimiter**.
* Mounts all routers (**userRoutes**, **moduleRoutes**, **quizRoutes**, **examRoutes**, etc.) under **/api/v1**.
* Includes the global error handler middleware last.

### 4. Admin Interface Implementation (Frontend)

A separate web-based Admin Interface is required to interact with the new backend Admin Endpoints.

* **Purpose**: Provide a UI for administrators to manage modules (create/edit Markdown content), manage exams (create metadata, trigger AI generation, edit), and manage quizzes (trigger AI generation, edit).

* **Technology Stack**: Recommended: React (matches React Native skills), Vue, Angular, or similar web framework. Can use component libraries like Material UI, Ant Design for faster UI development.

* **Key Features**:
  * Admin Login (using Firebase Authentication).
  * Dashboard/Navigation.
  * **Module Management**:
    * List existing modules.
    * Form to create a new module (inputs for title, description, etc.).
    * Rich Text/Markdown editor (e.g., react-markdown, react-mde) for creating/editing section content within the form.
    * Ability to add/remove/reorder sections.
    * Edit existing modules.
    * Delete modules.

* **Exam Management**:
  * List existing exams.
  * Form to create/edit exam metadata (title, description, duration, associatedModules).
  * Button to "Generate/Regenerate Exam Questions" (calls POST /api/v1/exams/generate-and-save).
  * Display area to view/potentially edit the stored generated questions.
  * Delete exams.

* **Quiz Management**:
  *List existing stored quizzes.
  *Mechanism to select a Module and trigger Quiz generation (calls POST /api/v1/quizzes/generate-and-save).
  *Display area to view/edit stored quiz questions.
  *Delete quizzes.

* **Alternatives**: As mentioned before, low-code tools (Retool, Appsmith) or simply using API clients (Postman) can be intermediate steps, but a dedicated interface is best for usability.

### 5. User Initialization (functions/)

Implement the Firebase Auth **onCreate** trigger to automatically create Firestore documents for new users.

Add this code to functions/index.js:

```javascript
// functions/index.js (or functions/src/index.js)

const functions = require('firebase-functions');
const admin = require('firebase-admin');
const sgMail = require('@sendgrid/mail');

// Initialize Admin SDK (runs only once on cold start)
try {
  if (admin.apps.length === 0) { // Prevent re-initialization
       admin.initializeApp();
  }
} catch (e) {
  console.error('Firebase admin initialization error', e);
}
const db = admin.firestore(); // Define db globally here

// Set SendGrid API Key
try {
    sgMail.setApiKey(functions.config().sendgrid.key);
} catch (e) {
    console.error('SendGrid API key configuration error. Make sure functions config sendgrid.key is set.', e);
}


// --- Existing Callable Function ---
exports.updateEmailSubscription = functions.https.onCall(async (data, context) => {
  // ... (your existing, refined code) ...
});

// --- NEW Auth Trigger Function ---
exports.initializeNewUser = functions.auth.user().onCreate(async (user) => {
    functions.logger.log(`Initializing Firestore document for new user: ${user.uid} (${user.email})`);

    const userRef = db.collection('users').doc(user.uid);

    // Default data for a new user
    const newUserProfile = {
        uid: user.uid,
        email: user.email || null,
        displayName: user.displayName || 'New User',
        photoURL: user.photoURL || 'YOUR_DEFAULT_AVATAR_URL_HERE', // <-- SET A DEFAULT URL
        createdAt: admin.firestore.FieldValue.serverTimestamp(),
        bio: '',
        lastLogin: admin.firestore.FieldValue.serverTimestamp(),
        learningProgress: {
            completedModules: [],
            completedQuizzes: [],
            completedExams: [],
            score: 0,
        },
        settings: {
            notificationsEnabled: true,
            darkMode: false,
            emailUpdates: true,
            syncData: true,
            soundEffects: false,
        },
    };

    try {
        await userRef.set(newUserProfile);
        functions.logger.log(`Successfully created Firestore user document for ${user.uid}`);

        // Optional: Create a welcome notification
        const notificationRef = db.collection('notifications').doc(); // Auto-ID
        await notificationRef.set({
             notificationId: notificationRef.id,
             userId: user.uid,
             title: 'Welcome to Cloud Explorer!',
             message: 'Start your cloud learning journey today!',
             type: 'welcome',
             read: false,
             createdAt: admin.firestore.FieldValue.serverTimestamp(),
        });
        functions.logger.log(`Welcome notification created for ${user.uid}`);

    } catch (error) {
        functions.logger.error(`Error creating Firestore user document for ${user.uid}:`, error);
    }
});
```

* **Deployment**:

1. Make sure you have the Firebase CLI installed and configured.
2. Navigate to your project root in the terminal.
3. Run: firebase deploy --only functions

### 6. Transition Plan

1. Implement Backend Admin Endpoints: Build and test the new protected endpoints in your Node.js/Express backend for managing modules, quizzes, and exams.
2. Implement Auth Trigger: Add and deploy the initializeNewUser Cloud Function.
3. Build Admin Interface: Create the admin frontend to interact with the new backend endpoints.
4. Initial Content Seed (Optional, One-Time):

   * Adapt your old create-schema.ts script (remove cleanup, user creation, progress sections).
   * Modify it to read your .md files and call your new POST /api/v1/modules endpoint for each module.
   * Modify it to call your new POST /api/v1/exams/create endpoint for each exam's metadata.
   * Modify it to call your new POST /api/v1/quizzes/generate-and-save and POST /api/v1/exams/generate-and-save endpoints once for each initial quiz/exam to populate the stored questions.
   * Run this adapted script once against your development/staging environment, then production, after the backend endpoints and auth trigger are deployed.

5. Retire Old Script: Remove or archive the original create-schema.ts script to prevent accidental execution.
6. Frontend API Updates: Ensure your React Native application is updated to use the correct /api/v1/... endpoints for fetching content and posting results, as discussed previously.

7. Conclusion

By implementing these changes, Cloud Explorer will transition to a robust, scalable system. Content management becomes centralized and dynamic via admin tools, and user initialization is automated. This lays a solid foundation for future growth and feature additions.
